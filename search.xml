<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>英语听力考点分析及必备技能</title>
      <link href="/post/705ff027/"/>
      <url>/post/705ff027/</url>
      
        <content type="html"><![CDATA[<h1 id="考点分析"><a class="markdownIt-Anchor" href="#考点分析"></a> 考点分析</h1><h2 id="视听一致考试占比60~70"><a class="markdownIt-Anchor" href="#视听一致考试占比60~70"></a> 视听一致，考试占比<code>60%~70%</code></h2><p>视听一致其实就是指<code>所听即所得</code>，听到的内容在试题中的选项出现了，那么这个选项就是正确的答案。</p><h2 id="听懂部分短语或词汇考试占比20左右"><a class="markdownIt-Anchor" href="#听懂部分短语或词汇考试占比20左右"></a> 听懂部分短语或词汇，考试占比<code>20%</code>左右</h2><p>比如在听力中出现了<code>important</code>，那么在选项中可能会被替换成同义词如<code>crucial</code>。</p><p>这就需要大家能够听懂听力句子中的部分短语或词汇，通过选项中同义词的体现来找出正确答案。</p><h2 id="结合大段材料推断考试占比10~20"><a class="markdownIt-Anchor" href="#结合大段材料推断考试占比10~20"></a> 结合大段材料推断，考试占比<code>10%~20%</code></h2><p>在听懂的基础上，听懂它的材料内容，通过材料中的几句话或整体内容来选出正确答案。</p><p>根据听力考试占比和考试分数，能够做到视听一致基本上就没有问题了，那么掌握视听一致需要什么技能呢。</p><h1 id="解题技能"><a class="markdownIt-Anchor" href="#解题技能"></a> 解题技能</h1><h2 id="听音辩词"><a class="markdownIt-Anchor" href="#听音辩词"></a> 听音辩词</h2><p><strong>能够识别音频中读到的是哪个单词</strong>，这是基础</p><h2 id="听音识意"><a class="markdownIt-Anchor" href="#听音识意"></a> 听音识意</h2><p><strong>知道音频中某些单词的具体意思</strong>，相对进阶</p><h2 id="同义替换"><a class="markdownIt-Anchor" href="#同义替换"></a> 同义替换</h2><p><strong>知道音频中某些单词的同义词</strong>，能够提高选项的正确率</p><h2 id="视听一致"><a class="markdownIt-Anchor" href="#视听一致"></a> 视听一致</h2><p>其实就是上述三个技能的结合，某个选项中与音频中所听内容重合度最高的即为正确答案。</p><h1 id="借助真题提升得分能力"><a class="markdownIt-Anchor" href="#借助真题提升得分能力"></a> 借助真题提升得分能力</h1><p>当你在做真题时，需要掌握这几个技巧才能提升听力的得分能力。</p><ol><li><p><strong>圈画</strong></p><p>就是将选项中<code>关键词</code>圈画出来，如果是长选项则圈画<code>名词短语</code>。</p></li><li><p><strong>核对</strong></p><p>将答案和出题点进行核对，看下这题你为什么选错了，哪个词没有听出来，那么这就是你的<code>听力盲点</code>，接着进入下一步复听。</p></li><li><p><strong>复听</strong></p><p>反复地听这一听力盲点和单词，并同时做复读这一动作。</p></li><li><p><strong>复读</strong></p><p>因为很多时候我们听不出来是因为我们不会读，所以复读具有一定的重要性。</p></li></ol><div class="note info">            <p>通过这样一种做真题的方式和技能的训练，对于听力能力的提升是非常显著的。</p>          </div><hr />]]></content>
      
      
      <categories>
          
          <category> 英语四级 </category>
          
          <category> 听力技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> 听力 </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语四级必备同义替换词100+</title>
      <link href="/post/aacc19e6/"/>
      <url>/post/aacc19e6/</url>
      
        <content type="html"><![CDATA[<h1 id="替换词的重要性"><a class="markdownIt-Anchor" href="#替换词的重要性"></a> 替换词的重要性</h1><p>替换词可理解为更高级的同义词。</p><p>积累替换词不仅在英语听力中可以帮我们提高选项的正确性，在作文写作和翻译作答时运用替换词还能提高得分率。</p><p>下面列举在考试十分常用和常见的替换词以及部分单词的逻辑关系，运用时直接替换即可！</p><hr /><h1 id="副词-adv"><a class="markdownIt-Anchor" href="#副词-adv"></a> 副词 adv.</h1><h2 id="firstly"><a class="markdownIt-Anchor" href="#firstly"></a> firstly</h2><p><code>列举</code>关系，多用于段落<code>开头</code></p><ol><li><strong>initially</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：最初，首先，开头</span></span><h2 id="then"><a class="markdownIt-Anchor" href="#then"></a> then</h2><p>与 <code>fisrt</code> 连用时具有<code>列举</code>关系，多用于表示<code>递进</code></p><ol><li><strong>subsequently</strong> [区别于 <code>so</code> 的替换词 <code>consequently</code>]</li><li><strong>afterward</strong></li><li><strong>thereafter</strong> [区别于 <code>so</code> 的替换词 <code>therefore</code>]</li><li><strong>in addition</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：然后，那么，于是，当时，此外</span></span><h2 id="lastly"><a class="markdownIt-Anchor" href="#lastly"></a> lastly</h2><p>具有<code>列举</code>关系，多用于<code>结尾</code>段落表示<code>总结</code></p><ol><li><strong>in conclusion</strong></li><li><strong>last but not least</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：最后，终于</span></span><h2 id="too"><a class="markdownIt-Anchor" href="#too"></a> too</h2><p><code>too...to...</code>：太…以至于…，具有<code>因果</code>关系</p><p>替换词多用于<code>比较</code>或<code>并列</code>关系</p><ol><li><strong>plus</strong></li><li><strong>as well as</strong></li><li><strong>bonus</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：太；也；很；还；非常；过度</span></span><h2 id="or"><a class="markdownIt-Anchor" href="#or"></a> or</h2><p>具有<code>并列</code>关系的同时多用于表示<code>两种相反的结果</code>，句子中通常有两种相反的结果出现。</p><ol><li><strong>otherwise</strong></li><li><strong>if not</strong></li><li><strong>or else</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：否则；另外；如果不；在其他方面</span></span><h2 id="so"><a class="markdownIt-Anchor" href="#so"></a> so</h2><p>这里的 so 多指用于<code>因果</code>关系，表<code>结果</code></p><ol><li><p><strong>therefore</strong> [区别于 <code>then</code> 的替换词 <code>thereafter</code>]</p></li><li><p><strong>thus</strong></p></li><li><p><strong>consequently</strong> [区别于 <code>then</code> 的替换词 <code>subsequently</code>]</p></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：因此；结果；所以</span></span><h2 id="nowadays"><a class="markdownIt-Anchor" href="#nowadays"></a> nowadays</h2><ol><li><strong>currently</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：现今，当下，当前</span></span><h2 id="often"><a class="markdownIt-Anchor" href="#often"></a> often</h2><ol><li><strong>frequently</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】： 频繁地，经常地；时常，屡次</span></span><h2 id="about"><a class="markdownIt-Anchor" href="#about"></a> about</h2><p>这里的 <code>about</code> 是作为 副词 <code>adv.</code> ，当其为 介词 <code>prep.</code> 时译为<code>关于</code>；<code>因为</code>；<code>在……附近</code>；</p><ol><li><strong>approximately</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】： 大约，近似地；近于</span></span><h2 id="very"><a class="markdownIt-Anchor" href="#very"></a> very</h2><p>常与<code>形容词</code>连用，起<code>程度加深</code>的作用</p><ol><li><strong>extremely</strong></li><li><strong>greatly</strong></li><li><strong>highly</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：非常，很；完全；（非正式）典型地；最</span></span><h1 id="连词-conj"><a class="markdownIt-Anchor" href="#连词-conj"></a> 连词 conj.</h1><h2 id="because"><a class="markdownIt-Anchor" href="#because"></a> because</h2><p>用于<code>因果</code>关系，表示<code>原因</code></p><ol><li><p><strong>due to</strong> [这是一个副词 <code>adv.</code>，但用法类似 because]</p></li><li><p><strong>for the reason that</strong></p></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：因为，由于；由于...的原因</span></span><h2 id="but"><a class="markdownIt-Anchor" href="#but"></a> but</h2><p>用于<code>转折</code>关系</p><ol><li><strong>nevertheless</strong></li><li><strong>however</strong></li><li><strong>nonetheless</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：但是，可是；然而，不过；尽管如此</span></span><h1 id="形容词-adj"><a class="markdownIt-Anchor" href="#形容词-adj"></a> 形容词 adj.</h1><h2 id="important"><a class="markdownIt-Anchor" href="#important"></a> important</h2><p>形容<code>程度</code>或<code>事物</code>深、重要的词语</p><ol><li><strong>significant</strong></li><li><strong>vital</strong></li><li><strong>crucial</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：重要的，重大的；有地位的；决定性的</span></span><h2 id="interesting"><a class="markdownIt-Anchor" href="#interesting"></a> interesting</h2><ol><li><strong>amusing</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：有趣的，好玩的；引人发笑的</span></span><h2 id="famous"><a class="markdownIt-Anchor" href="#famous"></a> famous</h2><ol><li><strong>renowned</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：著名的；有声望的</span></span><h2 id="unbelievable"><a class="markdownIt-Anchor" href="#unbelievable"></a> unbelievable</h2><ol><li><strong>incredible</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：不能相信的，难以置信的；极好的，极大的</span></span><h2 id="common"><a class="markdownIt-Anchor" href="#common"></a> common</h2><p><code>common</code> 及下方所有替换词都具有<code>名词 n.</code> 和<code>形容词 adj.</code> 的特性</p><ol><li><p><strong>commonplace</strong> <span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：（n.）： 司空见惯的事，普通的东西；老生常谈；（adj.）： 凡的，普通的；平庸的，陈腐的</span></span></p></li><li><p><strong>universal</strong> <span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：（n.）：普遍的；共同的，通用的；宇宙的；全世界的；全体的；（adj.）： 一般概念；普通性</span></span></p></li></ol><h2 id="rich"><a class="markdownIt-Anchor" href="#rich"></a> rich</h2><ol><li><strong>wealthy</strong></li><li><strong>affluent</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：富有的，富裕的；丰富的</span></span><h2 id="good"><a class="markdownIt-Anchor" href="#good"></a> good</h2><ol><li><p><strong>excellent</strong></p></li><li><p><strong>terrific</strong></p></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：优秀的，杰出的，极好的；极其的</span></span><h2 id="best"><a class="markdownIt-Anchor" href="#best"></a> best</h2><ol><li><strong>optimal</strong> [区别于 <code>use</code> 的替换词 <code>optimize</code> （vt./vi.）]</li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：最棒的，最佳的；最理想的</span></span><h2 id="different"><a class="markdownIt-Anchor" href="#different"></a> different</h2><ol><li><strong>various</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】： 不同的，各种各样的；多方面的</span></span><h2 id="difficult"><a class="markdownIt-Anchor" href="#difficult"></a> difficult</h2><ol><li><strong>formidable</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：令人敬畏的；艰难的；强大的；可怕的</span></span><h2 id="many"><a class="markdownIt-Anchor" href="#many"></a> many</h2><ol><li><strong>numerous</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：许多的，很多的</span></span><h2 id="expensive"><a class="markdownIt-Anchor" href="#expensive"></a> expensive</h2><ol><li><strong>pricey</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：高价的，过分昂贵的</span></span><h2 id="complex"><a class="markdownIt-Anchor" href="#complex"></a> complex</h2><ol><li><strong>intricate</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：复杂的；缠结的；合成的</span></span><h2 id="whole"><a class="markdownIt-Anchor" href="#whole"></a> whole</h2><ol><li><strong>entire</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：全部的，整个的；全体的</span></span><h2 id="strange"><a class="markdownIt-Anchor" href="#strange"></a> strange</h2><ol><li><strong>weird</strong></li><li><strong>eccentric</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：陌生的；不寻常的；奇怪的；不可思议的</span></span><h2 id="dangerous"><a class="markdownIt-Anchor" href="#dangerous"></a> dangerous</h2><ol><li><strong>hazardous</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：有危险的；冒险的</span></span><h1 id="名词-n"><a class="markdownIt-Anchor" href="#名词-n"></a> 名词 n.</h1><h2 id="people-person"><a class="markdownIt-Anchor" href="#people-person"></a> people / person</h2><ol><li><strong>citizen</strong> <span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：市民，公民</span></span></li><li><strong>individual</strong>  [既是名词 n，也是形容词 adj. ]  <span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：（n.）：个人，个体；（adj.）：个人的，个别的，独特的</span></span></li></ol><h2 id="friends"><a class="markdownIt-Anchor" href="#friends"></a> friends</h2><ol><li><strong>companions</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：朋友；同伴；同事</span></span><h2 id="development"><a class="markdownIt-Anchor" href="#development"></a> development</h2><ol><li><strong>advancement</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：发展；进步；开发</span></span><h2 id="result"><a class="markdownIt-Anchor" href="#result"></a> result</h2><ol><li><strong>consequence</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：结果；重要性；推论</span></span><p>[ 词根：<code>consequent</code> （adj.）: 作为结果的 ]<br />[ 联想记忆：so 的替换词 <code>consequently</code> ]<br />[ 区分词：<code>subsequent</code> （adj.）： 随后的，后来的，then 的替换词 <code>subsequently</code> ]</p><h1 id="实义动词谓语动词-vt"><a class="markdownIt-Anchor" href="#实义动词谓语动词-vt"></a> 实义动词（谓语动词） vt.</h1><h2 id="use"><a class="markdownIt-Anchor" href="#use"></a> use</h2><ol><li><strong>optimize</strong></li></ol><p>[区别于 <code>best</code> 的替换词 <code>optimal</code> （adj. ）]</p><p>[ <code>optimize</code> 表示<code>程度</code>更优的，意为“<code>更好的去使用/利用...</code>”，作为非谓语动词 vi. 时有“优化，对…保持乐观态度”的意思]</p><ol start="2"><li><strong>utilize</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：使用；利用</span></span><h2 id="show"><a class="markdownIt-Anchor" href="#show"></a> show</h2><ol><li><strong>illustrate</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：显示；说明；展示；举例</span></span><h1 id="短语或句式"><a class="markdownIt-Anchor" href="#短语或句式"></a> 短语或句式</h1><h2 id="i-think-that"><a class="markdownIt-Anchor" href="#i-think-that"></a> I think (that) …</h2><p>多用于<code>陈述</code>观点或表达意见</p><ol><li><p><strong>be convinced of</strong>  [例句：<strong>I’m convinced of</strong> his guilt. （我确信他有罪。）]</p></li><li><p>I <strong>hold the opinion that …</strong></p></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：想...；认为...</span></span><h2 id="more-and-more"><a class="markdownIt-Anchor" href="#more-and-more"></a> more and more</h2><p><code>more and more</code> 常作为形容词<code>adj.</code>，来形容<code>数量的增加</code>，也可作为副词<code>adv.</code>，表示<code>程度的加深或加重</code></p><ol><li><strong>increasing</strong> <span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：（adv.）： 越来越多的；渐增的</span></span></li><li><strong>increasingly</strong> <span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：（adv.）： 越来越多地；渐增地</span></span></li></ol><p>[词根：increase v. 提高，增加，增大，增强 ]</p><h2 id="keep-on-hand-on-to-stick-to"><a class="markdownIt-Anchor" href="#keep-on-hand-on-to-stick-to"></a> keep on / hand on to / stick to …</h2><ol><li><strong>adhere to …</strong></li><li><strong>cling to …</strong></li></ol> <span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：坚持...；执着于...；依附于...</span></span><h2 id="depend-on"><a class="markdownIt-Anchor" href="#depend-on"></a> depend on</h2><ol><li><strong>hinge on</strong></li></ol><span class="hide-inline"><a class="hide-button button--primary button--animated" style="color:#fff;"> 查看词义    </a><span class="hide-content">【词义】：（adv.）：取决于…，依赖于...</span></span><hr /><h1 id="如果你需要更多的话"><a class="markdownIt-Anchor" href="#如果你需要更多的话"></a> 如果你需要更多的话</h1>]]></content>
      
      
      <categories>
          
          <category> 英语四级 </category>
          
          <category> 必备知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> 替换词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看完这篇，别人的开源项目结构应该能看懂了</title>
      <link href="/post/29fc4a32/"/>
      <url>/post/29fc4a32/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>很多小伙伴表示网上下载下来的开源项目看不懂，项目结构和代码分层看得很蒙，不知道应该以一个什么样的思路去学习和吸收别人的项目。</p><p>今天和大家一起来交流探讨一下，不足之处也请小伙伴们批评指正。</p><hr /><h1 id="先看看阿里是怎么约定的"><a class="markdownIt-Anchor" href="#先看看阿里是怎么约定的"></a> 先看看阿里是怎么约定的</h1><p>以前在看《阿里巴巴Java开发手册》时，好像有关于工程结构和应用分层相关的内容，于是我回翻了一下，果然有：</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/12/Hkn2TPrExvfdbsp.png"  alt="ali_struct" /></p><p>它这里面讲的内容大概就是：关于一个正常的企业项目里一种<strong>通用的项目结构和代码层级划分</strong>的指导意见。</p><p>按这本书上说的，一般分为如下几层：</p><ul><li><p><strong>开放接口层</strong>：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</p></li><li><p><strong>终端显示层</strong>：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</p></li><li><p><strong>Web 层</strong>：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</p></li><li><p><strong>Service 层</strong>：相对具体的业务逻辑服务层。</p></li><li><p><strong>Manager 层</strong>：通用业务处理层，它有如下特征：</p><ul><li>对第三方平台封装的层，预处理返回结果及转化异常信息；</li><li>对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；</li><li>与 DAO 层交互，对多个 DAO 的组合复用。</li></ul></li><li><p><strong>DAO 层</strong>：数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。</p></li><li><p><strong>外部接口或第三方平台</strong>：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</p></li></ul><p>接下来<strong>结合实际项目代码结构</strong>，来唠一唠具体的项目结构和代码分层。</p><hr /><h1 id="通常的项目结构"><a class="markdownIt-Anchor" href="#通常的项目结构"></a> 通常的项目结构</h1><div class="note info">            <p><strong>说在前面：这东西并没有一套通用的标准，不同公司或者团队的使用习惯和规范也不尽相同。</strong></p>          </div><p>我们就以当下非常火热的Spring Boot典型项目结构为例，创建出来的项目应该总体分为三大层：</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/12/jUD5eGcJRr78Sho.png"  alt="sb_struct" /></p><ul><li><code>项目根目录/src/main/java</code>：放置项目Java源代码</li><li><code>项目根目录/src/main/resources</code>：放置项目静态资源和配置文件</li><li><code>项目根目录/src/test/java</code>：放置项目测试用例代码</li></ul><p>位于<code>/src/main/java</code>目录下的Java源代码的组织结构是大家比较关心的地方，这地方也只能给出一个通常典型的结构，毕竟不同项目和团队实践不一样，稍许有区别，但整体安排应该差不多。</p><p>而且如果项目是<strong>多模块</strong>的话，下面的结构应该只对应其中一个模块，其他模块的代码组织也大致差不多。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/12/XC6ErwxQMp8jzsa.jpg"  alt="sb_mk" /></p><p>各个目录详细介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|_annotation：放置项目自定义注解</span><br><span class="line">|_aspect：放置切面代码</span><br><span class="line">|_config：放置配置类</span><br><span class="line">|_constant：放置常量、枚举等定义</span><br><span class="line">   |__consist：存放常量定义</span><br><span class="line">   |__enums：存放枚举定义</span><br><span class="line">|_controller：放置控制器代码</span><br><span class="line">|_filter：放置一些过滤、拦截相关的代码</span><br><span class="line">|_mapper：放置数据访问层代码接口</span><br><span class="line">|_model：放置数据模型代码</span><br><span class="line">   |__entity：放置数据库实体对象定义</span><br><span class="line">   |__dto：存放数据传输对象定义</span><br><span class="line">   |__vo：存放显示层对象定义</span><br><span class="line">|_service：放置具体的业务逻辑代码（接口和实现分离）</span><br><span class="line">   |__intf：存放业务逻辑接口定义</span><br><span class="line">   |__impl：存放业务逻辑实际实现</span><br><span class="line">|_utils：放置工具类和辅助代码</span><br></pre></td></tr></table></figure><p>然后接下来<code>/src/main/resources</code>目录，里面主要存放<code>静态配置文件</code>和<code>页面静态资源</code>等东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|_mapper：存放mybatis的XML映射文件（如果是mybatis项目）</span><br><span class="line">|_static：存放网页静态资源，比如下面的js&#x2F;css&#x2F;img</span><br><span class="line">   |__js：</span><br><span class="line">   |__css：</span><br><span class="line">   |__img：</span><br><span class="line">   |__font：</span><br><span class="line">   |__等等</span><br><span class="line">|_template：存放网页模板，比如thymeleaf&#x2F;freemarker模板等</span><br><span class="line">   |__header</span><br><span class="line">   |__sidebar</span><br><span class="line">   |__bottom</span><br><span class="line">   |__XXX.html等等</span><br><span class="line">|_application.yml       基本配置文件</span><br><span class="line">|_application-dev.yml   开发环境配置文件</span><br><span class="line">|_application-test.yml  测试环境配置文件</span><br><span class="line">|_application-prod.yml  生产环境配置文件</span><br></pre></td></tr></table></figure><p>当然，这地方估计有一个<strong>很多人都会纠结的</strong>关于<code>DTO/VO/DO</code>等<strong>数据模型定义</strong>的区分。</p><p>这在《阿里巴巴Java开发手册》中倒是做了一个所谓的严格区分，那本书上是这样去定义的：</p><ul><li><code>DO（Data Object）</code>：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li><code>DTO（Data Transfer Object）</code>：数据传输对象，Service或Manager向外传输的对象。</li><li><code>BO（Business Object）</code>：业务对象。由Service层输出的封装业务逻辑的对象。</li><li><code>AO（Application Object）</code>：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li><code>VO（View Object）</code>：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li><code>Query</code>：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。</li></ul><p>老实讲，看到这么多对象的定义，我也是很蒙的。实际项目开发时，我觉得没有必要刻意照搬去定义这么多层对象，这样后续做对象转换工作都能烦人。</p><p>出于简单起见，我个人觉得，只要保证业务逻辑层<code>Service</code>和数据库<code>DAO</code>层的操作对象严格划分出来，确保互相不渗透，不混用，问题应该就不大。</p><p>比如在我上面举例的这个项目的代码结构中，<code>Service</code>层处理的对象都定义在了<code>dto</code>包里，而<code>DAO</code>层处理的对象都放在了<code>entity</code>包里了。</p><hr /><h1 id="项目结构划分总结"><a class="markdownIt-Anchor" href="#项目结构划分总结"></a> 项目结构划分总结</h1><p>如果从一个用户访问一个网站的情况来看，对应着上面的项目代码结构来分析，可以贯穿整个代码分层：</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/12/LV2Wz9ceXiP8aMy.jpg"  alt="xm_gc" /></p><p>对应代码目录的流转逻辑就是：</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/12/Racwei8p6j7gCAt.jpg"  alt="sb_lz" /></p><p><strong>所以，以后每当我们拿到一个新的项目到手时，只要按照这个思路去看别人项目的代码，应该基本都是能理得顺的</strong>。</p><hr /><h1 id="一些注意事项"><a class="markdownIt-Anchor" href="#一些注意事项"></a> 一些注意事项</h1><p>1、<code>Contorller</code>层参数传递建议不要使用<code>HashMap</code>，建议使用数据模型定义</p><p>2、<code>Controller</code>层里可以做参数校验、异常抛出等操作，但建议不要放太多业务逻辑，业务逻辑尽量放到<code>Service</code>层代码中去做</p><p>3、<code>Service</code>层做实际业务逻辑，可以按照功能模块做好定义和区分，相互可以调用</p><p>4、功能模块<code>Service</code>之间引用时，建议不要渗透到<code>DAO</code>层（或者<code>mapper</code>层），基于<code>Service</code>层进行调用和复用比较合理</p><p>5、业务逻辑层<code>Service</code>和数据库<code>DAO</code>层的操作对象不要混用。<code>Controller</code>层的数据对象不要直接渗透到<code>DAO</code>层（或者<code>mapper</code>层）；同理数据表实体对象<code>Entity</code>也不要直接传到<code>Controller</code>层进行输出或展示。</p><hr />]]></content>
      
      
      <categories>
          
          <category> 干货分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 项目结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解TCP三次握手和四次挥手及相关面试题</title>
      <link href="/post/fa9f52/"/>
      <url>/post/fa9f52/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><blockquote><p>阅前需知：字节是二进制数据的单位。一个字节通常8位长。</p></blockquote><p>不管面试 Java 、C/C++、Python 等开发岗位， <code>TCP</code> 的知识点可以说是的必问的了。</p><p><strong>任 TCP 虐我千百遍，我仍待 TCP 如初恋。</strong></p><p>这里整理了关于 <strong>TCP 三次握手和四次挥手的面试题型</strong>，跟大家一起探讨探讨。</p><ol><li><p><strong>TCP 基本认识</strong></p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/kFHgQeY736y9LEd.jpg"  alt="tcp1" /></p></li><li><p><strong>TCP 连接建立</strong></p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/tcJblrvVidFA7pN.jpg"  alt="tcp2" /></p></li><li><p><strong>TCP 连接断开</strong></p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/DBFsuoJYVrGSR3N.jpg"  alt="tcp3" /></p></li><li><p><strong>Socket 编程</strong></p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/2iFLIY1aW4BQvux.jpg"  alt="tcp4" /></p></li></ol><div class="note info">            <p>本次文章不涉及 TCP 流量控制、拥塞控制、可靠性传输等方面知识</p>          </div><hr /><h1 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h1><h2 id="tcp-基本认识"><a class="markdownIt-Anchor" href="#tcp-基本认识"></a> TCP 基本认识</h2><h3 id="tcp-头格式"><a class="markdownIt-Anchor" href="#tcp-头格式"></a> TCP 头格式</h3><blockquote><p>我们先来看看 <code>TCP 头部格式</code>，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。</p></blockquote><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/skBtSlUw9Kijz2C.jpg"  alt="TCP 头格式" /></p><ul><li><p><strong>序列号</strong>：</p><p>在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就<code>累加</code>一次该<code>数据字节数</code>的大小。<strong>用来解决网络包乱序问题。</strong></p></li><li><p><strong>确认应答号</strong>：</p><p>指下一次<code>期望</code>收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决不丢包的问题。</strong></p></li><li><p><strong>控制位【图中的黄色区域】：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，<code>确认应答</code>的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYC</em>：该位为 <code>1</code> 时，表示希望建立连，并在其<code>序列号</code>的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</li></ul></li></ul><h3 id="为什么需要-tcp-协议tcp-工作在哪一层"><a class="markdownIt-Anchor" href="#为什么需要-tcp-协议tcp-工作在哪一层"></a> 为什么需要 TCP 协议？TCP 工作在哪一层？</h3><p><code>IP</code> 层（<code>网络层</code>）是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/2bcjFZ4rVgHB5N1.jpg"  alt="OSI参考模型与TCP/IP的关系" /></p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 <code>TCP</code> 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h3 id="什么是-tcp"><a class="markdownIt-Anchor" href="#什么是-tcp"></a> 什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的<code>传输层通信协议</code>。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/iFjbptSslNRZ36z.jpg"  alt="tcp_what" /></p><ul><li><p><strong>面向连接</strong>：</p><p>一定是<code>一对一</code>才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p></li><li><p><strong>可靠的</strong>：</p><p>无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p></li><li><p><strong>字节流</strong>：</p><p>消息是<code>没有边界</code>的，所以无论我们消息有多大都可以进行传输。并且消息是<code>有序的</code>，当<code>前一个</code>消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对<code>重复</code>的报文会自动丢弃。</p></li></ul><h3 id="什么是-tcp-连接"><a class="markdownIt-Anchor" href="#什么是-tcp-连接"></a> 什么是 TCP 连接？</h3><p>我们来看看 RFC 793 是如何定义<code>连接</code>的：</p><blockquote><p><em>Connections:</em></p><p><em>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream.</em></p><p><em>The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</em></p></blockquote><p>简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/D2vyu9zUSRKV5BL.jpg"  alt="tcp_link" /></p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h3 id="如何唯一确定一个-tcp-连接呢"><a class="markdownIt-Anchor" href="#如何唯一确定一个-tcp-连接呢"></a> 如何唯一确定一个 TCP 连接呢？</h3><p><code>TCP 四元组</code>可以唯一地确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/O4SxzAwye58XPQq.png"  alt="tcp_f4" /></p><p><code>源地址</code>和<code>目的地址</code>的字段（32位）是在 <code>IP 头部</code>中，作用是<strong>通过 IP 协议发送报文给对方主机</strong>。</p><p><code>源端口</code>和<code>目的端口</code>的字段（16位）是在 <code>TCP 头部</code>中，作用是<strong>告诉 TCP 协议应该把报文发给哪个进程</strong>。</p><h3 id="tcp-的最大连接数是多少"><a class="markdownIt-Anchor" href="#tcp-的最大连接数是多少"></a> TCP 的最大连接数是多少？</h3><blockquote><p>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</p></blockquote><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p><p>因此，客户端 IP 和 端口是<code>可变的</code>，其理论值计算公式如下:</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/onU1NydwKe8HVlX.jpg"  alt="tcp_link_maxnum" /></p><p>对 IPv4，客户端的 IP 数最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，客户端的端口数最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>，也就是服务端单机最大 TCP 连接数，约为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。</p><ul><li>首先主要是<strong>文件描述符限制</strong>，Socket 都是文件，所以首先要通过 <code>ulimit</code> 配置文件描述符的数目；</li><li>另一个是<strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统是有限的。</li></ul><h3 id="什么是-udp"><a class="markdownIt-Anchor" href="#什么是-udp"></a> 什么是 UDP ?</h3><p>UDP 不提供复杂的控制机制，是利用 IP 提供面向<code>无连接</code>的通信服务。</p><p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（ 64 位），UDP 的头部格式如下：</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/lOwVgxt9dFJaGhN.jpg"  alt="udp_head" /></p><ul><li><strong>源和目标端口号</strong>：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li><strong>包长度</strong>：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li><strong>校验和</strong>：校验和是为了提供可靠的 UDP 首部和数据而设计。</li></ul><h3 id="tcp-和-udp-的区别"><a class="markdownIt-Anchor" href="#tcp-和-udp-的区别"></a> TCP 和 UDP 的区别</h3><p><strong>1. 连接</strong></p><ul><li>TCP  是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要建立连接，即刻传输数据。</li></ul><p><strong>2. 服务对象</strong></p><ul><li>TCP  是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><strong>3. 可靠性</strong></p><ul><li>TCP  是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li><li>UDP 是尽最大努力交付，不保证交付数据的可靠性。</li></ul><p><strong>4. 拥塞控制、流量控制</strong></p><ul><li>TCP  有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><strong>5. 首部开销</strong></p><ul><li><p>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</p></li><li><p>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</p></li></ul><blockquote><p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p></blockquote><p>原因是 TCP 有<strong>可变长</strong>的<code>选项</code>字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p><blockquote><p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p></blockquote><p>先说说 TCP 是如何计算负载数据长度：</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/WsIgyY5Zjh48Cak.jpg"  alt="tcp_lenght" /></p><p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。</p><p>TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p><blockquote><p>UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀！为何还要有「包长度」呢？</p></blockquote><p>这么一问，确实感觉 UDP <code>包长度</code>是冗余的。</p><p><strong>但为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code>字节的整数倍。</strong></p><p>如果去掉 UDP <code>包长度</code>字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以这可能是为了补全 UDP 首部长度是 <code>4</code> 字节的整数倍，才补充了<code>包长度</code>字段。</p><h3 id="tcp-和-udp-的应用场景"><a class="markdownIt-Anchor" href="#tcp-和-udp-的应用场景"></a> TCP 和 UDP 的应用场景</h3><p>由于 TCP 是面向连接的，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输</li><li><code>HTTP</code> / <code>HTTPS</code></li></ul><p>由于 UDP 是面向无连接的，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等</li><li>视频、音频等多媒体通信</li><li>广播通信，如直播</li></ul><hr /><h2 id="tcp-连接建立"><a class="markdownIt-Anchor" href="#tcp-连接建立"></a> TCP 连接建立</h2><h3 id="tcp-三次握手过程和状态变迁"><a class="markdownIt-Anchor" href="#tcp-三次握手过程和状态变迁"></a> TCP 三次握手过程和状态变迁</h3><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手而进行的。</strong></p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/8dW7qSPmOGLh2xR.jpg"  alt="tcp_create_link" /></p><ul><li><p>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。<br /><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/fsvMGRbCqQKF59N.jpg"  alt="tcp_syn" /></p></li><li><p>客户端会随机初始化序列号（<code>client_isn</code>），将此序列号置于 TCP 首部的<code>序列号</code>字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。</p></li><li><p>接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/9mGTyBj4uD5CqEX.jpg"  alt="tcp_2_syn+ack" /></p></li><li><p>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序列号（<code>server_isn</code>），将此序列号填入 TCP 首部的<code>序列号</code>字段中。</p></li><li><p>其次把从客户端接收到的<code>client_isn + 1</code>填入 TCP 首部的<code>确认应答号</code>字段, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。</p></li><li><p>最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/Ix3bMhWzN9GCQBs.jpg"  alt="tcp_3_ack" /></p></li><li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次在<code>确认应答号</code>字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</p></li><li><p>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</p><p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p></li></ul><h3 id="如何在-linux-系统中查看-tcp-状态"><a class="markdownIt-Anchor" href="#如何在-linux-系统中查看-tcp-状态"></a> 如何在 Linux 系统中查看 TCP 状态？</h3><p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/a5duQBLgIbwheoR.jpg"  alt="tcp_linux_state" /></p><h3 id="为什么是三次握手不是两次-四次"><a class="markdownIt-Anchor" href="#为什么是三次握手不是两次-四次"></a> 为什么是三次握手？不是两次、四次？</h3><p>相信大家常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”</p><p>这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p><p>在前面我们知道了什么是 <strong>TCP 连接</strong>：</p><ul><li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</li></ul><p>所以，重要的是<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。</strong></p><h3 id="以三个方面来分析三次握手的原因"><a class="markdownIt-Anchor" href="#以三个方面来分析三次握手的原因"></a> 以三个方面来分析三次握手的原因</h3><ul><li>三次握手才可以<strong>防止历史连接的初始化</strong>（主要原因）</li><li>三次握手才可以<strong>同步双方的初始序列号</strong></li><li>三次握手才可以<strong>避免资源浪费</strong></li></ul><h4 id="原因一避免历史连接序列号超期望-过期或超时"><a class="markdownIt-Anchor" href="#原因一避免历史连接序列号超期望-过期或超时"></a> 原因一：避免历史连接（序列号超期望、过期或超时）</h4><p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p><blockquote><p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p></blockquote><p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p><p>网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机。</p><blockquote><p>那么这种情况下 TCP 三次握手是如何避免的呢？</p></blockquote><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/1xNcBJgi4maAkv6.jpg"  alt="tcp_avoid_history_link" /></p><p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：</p><ul><li>一个<code>旧的 SVN 报文</code>比<code>最新的 SYN 报文</code>早到达了服务端；</li><li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接，那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li></ul><p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，可以通过足够的上下文来判断当前连接是否是历史连接：</p><ul><li>如果是历史连接，则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接；</li><li>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接；</li></ul><p>所以， TCP 使用三次握手建立连接的<code>最主要原因</code>是<strong>防止历史连接初始化了连接。</strong></p><h4 id="原因二同步双方的初始序列号"><a class="markdownIt-Anchor" href="#原因二同步双方的初始序列号"></a> 原因二：同步双方的初始序列号</h4><p>TCP 协议的通信双方， 都必须维护一个<code>序列号</code>， 序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li></ul><p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带<code>初始序列号</code>的 <code>SYN</code> 报文的时候，需要服务端返回 ``SYN + ACK<code>应答报文，表示客户端的 SVN 报文已被服务端成功接收，那当服务端发送</code>初始序列号`给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/gWIwENP53xhZplY.jpg"  alt="tcp_4w" /></p><p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了<code>三次握手</code>。</p><p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p><h4 id="原因三避免资源浪费"><a class="markdownIt-Anchor" href="#原因三避免资源浪费"></a> 原因三：避免资源浪费</h4><p>如果只有<code>两次握手</code>，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接，这会造成什么情况呢？</p><p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/tZIWuc6RS3C2VlK.jpg"  alt="tcp_2w" /></p><p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能帮助双方同步初始化序列号，能减少双方不必要的资源开销</strong>。</p><p>序列号能够保证数据包不重复、不丢弃和按序传输。</p><p>不使用<code>两次握手</code>和<code>四次握手</code>的原因：</p><ul><li><strong>两次握手</strong>：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li><strong>四次握手</strong>：三次握手理论上就已经可以最少的通信次数将可靠连接建立，所以不需要使用更多的通信次数。</li></ul><h3 id="为什么客户端和服务端的初始序列号-isn-是不相同的"><a class="markdownIt-Anchor" href="#为什么客户端和服务端的初始序列号-isn-是不相同的"></a> 为什么客户端和服务端的初始序列号 ISN 是不相同的？</h3><p>因为网络中的报文<strong>会延迟、会复制重发、也有可能丢失</strong>，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</p><h3 id="初始序列号-isn-是如何随机产生的"><a class="markdownIt-Anchor" href="#初始序列号-isn-是如何随机产生的"></a> 初始序列号 ISN 是如何随机产生的？</h3><p>起始 <code>ISN</code> 是基于时钟的，每 4 毫秒 + 1，转一圈要 4.55 个小时。</p><p>RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。</p><p><em>ISN = M + F (localhost, localport, remotehost, remoteport)</em></p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 毫秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法加密是一个比较好的选择。</li></ul><h3 id="既然-ip-层会分片为什么-tcp-层还需要-mss-呢"><a class="markdownIt-Anchor" href="#既然-ip-层会分片为什么-tcp-层还需要-mss-呢"></a> 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><p>先来认识下 MTU 和 MSS</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/cKxF4a1R9de8Dhu.jpg"  alt="tcp_mtu_mss" /></p><ul><li><p><strong>MTU</strong>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</p></li><li><p><strong>MSS</strong>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</p></li></ul><blockquote><p>如果TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</p></blockquote><p>当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，在交给上一层 TCP 传输层。</p><p>这看起来井然有序，但这存在隐患的，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</p><p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p><p>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</p><p>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p><p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/fh69WaL27e8qBKn.jpg"  alt="tcp_mss" /></p><p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p><h3 id="什么是-syn-攻击如何避免-syn-攻击"><a class="markdownIt-Anchor" href="#什么是-syn-攻击如何避免-syn-攻击"></a> 什么是 SYN 攻击？如何避免 SYN 攻击？</h3><h4 id="syn-攻击"><a class="markdownIt-Anchor" href="#syn-攻击"></a> SYN 攻击</h4><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/R5s6mvWDUOfXP7K.jpg"  alt="tcp_syn_attack" /></p><h4 id="避免-syn-攻击方式一"><a class="markdownIt-Anchor" href="#避免-syn-攻击方式一"></a> 避免 SYN 攻击方式一</h4><p>其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p><ul><li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.netdev_max_backlog</span><br></pre></td></tr></table></figure><ul><li>SYN_RCVD 状态连接的最大个数：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><ul><li>超出处理能时，对新的 SYN 直接回 RST，丢弃连接：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><h4 id="避免-svn-攻击方式二"><a class="markdownIt-Anchor" href="#避免-svn-攻击方式二"></a> 避免 SVN 攻击方式二</h4><p>先来看下Linux 内核的 <code>SYN</code> （未完成连接建立）队列与 <code>Accpet</code> （已完成连接建立）队列是如何工作的？</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/DQbueowTnL72EzH.jpg"  alt="linux_syn_list" /></p><p><strong>正常流程</strong>：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的 <code>SYN 队列</code>；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从 <code>SYN 队列</code>移除放入到 <code>Accept 队列</code>；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从 <code>Accept 队列</code>取出的连接。</li></ul><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/YCxqNh2epEiGlja.jpg"  alt="linux_syn_list_slow" /></p><p><strong>应用程序过慢</strong>：</p><ul><li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li></ul><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/TBltxyf3S19JbPK.jpg"  alt="linux_syn_attack" /></p><p><strong>受到 SYN 攻击</strong>：</p><ul><li>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。</li></ul><p><code>tcp_syncookies</code> 的方式可以应对 SYN 攻击的方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/YszhcIAqryuxPVl.jpg"  alt="linux_syn_cookie" /></p><p><strong>SYN 队列占满，启动Cookie</strong>：</p><ul><li>当 <code>SYN 队列</code>满之后，后续服务器收到 SYN 包，不进入<code>SYN 队列</code>；</li><li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的<code>序列号</code>返回客户端，</li><li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到<code>Accept 队列</code>。</li><li>最后应用通过调用 <code>accpet()</code> socket 接口，从<code>Accept 队列</code>取出的连接。</li></ul><hr /><h2 id="tcp-连接断开"><a class="markdownIt-Anchor" href="#tcp-连接断开"></a> TCP 连接断开</h2><h3 id="tcp-四次挥手过程和状态变迁"><a class="markdownIt-Anchor" href="#tcp-四次挥手过程和状态变迁"></a> TCP 四次挥手过程和状态变迁</h3><p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过<strong>四次挥手</strong>方式。</p><p>双方都可以主动断开连接，断开连接后主机中的<code>资源</code>将被释放。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/EgyNuXk8D2Y1c3e.jpg"  alt="tcp_4h" /></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h3 id="为什么挥手需要四次"><a class="markdownIt-Anchor" href="#为什么挥手需要四次"></a> 为什么挥手需要四次？</h3><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p><h3 id="为什么-time_wait-等待的时间是-2msl"><a class="markdownIt-Anchor" href="#为什么-time_wait-等待的时间是-2msl"></a> 为什么 TIME_WAIT 等待的时间是 2MSL？</h3><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p><p>MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p><p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p><p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p><p>其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="comment">/* how long to wait to destroy TIME-WAIT</span></span></span><br><span class="line"><span class="meta"><span class="comment">                                    state, about 60 seconds  */</span></span></span><br></pre></td></tr></table></figure><p>如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。</p><h3 id="为什么需要-time_wait-状态"><a class="markdownIt-Anchor" href="#为什么需要-time_wait-状态"></a> 为什么需要 TIME_WAIT 状态？</h3><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p><p>需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li>防止具有相同<code>四元组</code>的<code>旧数据包</code>被收到；</li><li>保证<code>被动关闭连接</code>的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li></ul><h4 id="原因一防止旧连接的数据包"><a class="markdownIt-Anchor" href="#原因一防止旧连接的数据包"></a> 原因一：防止旧连接的数据包</h4><blockquote><p>假设 TIME-WAIT 没有等待时间或时间过短，<code>被延迟的数据包抵达后</code>会发生什么呢？</p></blockquote><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/Bji2aCDRd7z4VWS.jpg"  alt="time-wait_error" /></p><ul><li>如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li><li>这时有相同端口的 TCP 连接被复用后，被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</li></ul><p>所以，TCP 就设计出了这么一个机制，经过 <code>2MSL</code> 这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><h4 id="原因二保证连接正确关闭"><a class="markdownIt-Anchor" href="#原因二保证连接正确关闭"></a> 原因二：保证连接正确关闭</h4><p>在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：</p><blockquote><p><em>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</em></p></blockquote><p>也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p><blockquote><p>假设 TIME-WAIT 没有等待时间或时间过短，<code>断开连接</code>会造成什么问题呢？</p></blockquote><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/5V6OotXhpKUqgJI.jpg"  alt="time-wait_error2" /></p><ul><li><p>如上图红色框客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。</p></li><li><p>当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</p></li></ul><p><strong>如果 TIME-WAIT 等待足够长的情况就会遇到两种情况</strong>：</p><ul><li>服务端正常收到四次挥手的最后一个 <code>ACK</code> 报文，则服务端正常关闭连接。</li><li>服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文。</li></ul><p>所以客户端在 <code>TIME-WAIT</code> 状态等待 <code>2MSL</code> 时间后，就可以<strong>保证双方的连接都可以正常的关闭。</strong></p><h3 id="time_wait-过多有什么危害"><a class="markdownIt-Anchor" href="#time_wait-过多有什么危害"></a> TIME_WAIT 过多有什么危害？</h3><p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。</p><p><strong>过多的 TIME-WAIT 状态主要的危害有两种</strong>：</p><ul><li>第一是内存资源占用；</li><li>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</li></ul><p>第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过如下参数设置指定</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range</span><br></pre></td></tr></table></figure><p><strong>如果服务端 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</strong></p><h3 id="如何优化-time_wait"><a class="markdownIt-Anchor" href="#如何优化-time_wait"></a> 如何优化 TIME_WAIT？</h3><p><strong>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊</strong>：</p><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li><li>net.ipv4.tcp_max_tw_buckets；</li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li></ul><h4 id="方式一netipv4tcp_tw_reuse-和-tcp_timestamps"><a class="markdownIt-Anchor" href="#方式一netipv4tcp_tw_reuse-和-tcp_timestamps"></a> 方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</h4><p>如下的 Linux 内核参数开启后，则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br></pre></td></tr></table></figure><p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps&#x3D;1（默认即为 1）</span><br></pre></td></tr></table></figure><p>这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。</p><p>由于引入了时间戳，我们在前面提到的 <code>2MSL</code> 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p><p>温馨提醒：<code>net.ipv4.tcp_tw_reuse</code>要慎用，因为使用了它就必然要打开时间戳的支持 <code>net.ipv4.tcp_timestamps</code>，<strong>当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</strong>。这个在工作中就遇到过。。。排查了非常的久</p><h4 id="方式二netipv4tcp_max_tw_buckets"><a class="markdownIt-Anchor" href="#方式二netipv4tcp_max_tw_buckets"></a> 方式二：net.ipv4.tcp_max_tw_buckets</h4><p>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接<strong>一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。</strong></p><p>这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</p><h4 id="方式三程序中使用-so_linger"><a class="markdownIt-Anchor" href="#方式三程序中使用-so_linger"></a> 方式三：程序中使用 SO_LINGER</h4><p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">so_linger</span>;</span></span><br><span class="line">so_linger.l_onoff = <span class="number">1</span>;</span><br><span class="line">so_linger.l_linger = <span class="number">0</span>;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,<span class="keyword">sizeof</span>(so_linger));</span><br></pre></td></tr></table></figure><p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p><p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p><h3 id="如果已经建立了连接但是客户端突然出现故障了怎么办"><a class="markdownIt-Anchor" href="#如果已经建立了连接但是客户端突然出现故障了怎么办"></a> 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP 有一个机制是<strong>保活机制</strong>。这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=<span class="number">7200</span></span><br><span class="line">net.ipv4.tcp_keepalive_intvl=<span class="number">75</span>  </span><br><span class="line">net.ipv4.tcp_keepalive_probes=<span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li><li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li><li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li></ul><p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个<code>死亡</code>连接。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/IcmdQa3vWe1nU4q.jpg"  alt="linux_tcp_die" /></p><p>这个时间是有点长的，我们也可以根据实际的需求，对以上的保活相关的参数进行设置。</p><p><strong>如果开启了 TCP 保活，需要考虑以下几种情况</strong>：</p><ul><li><p>对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p></li><li><p>对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</p></li><li><p>是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p></li></ul><hr /><h2 id="socket-编程"><a class="markdownIt-Anchor" href="#socket-编程"></a> Socket 编程</h2><h3 id="针对-tcp-应该如何-socket-编程"><a class="markdownIt-Anchor" href="#针对-tcp-应该如何-socket-编程"></a> 针对 TCP 应该如何 Socket 编程？</h3><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/njfvAPxEesYDUa3.jpg"  alt="tcp_socket" /></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是<code>两个</code>socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><h3 id="listen-时候参数-backlog-的意义"><a class="markdownIt-Anchor" href="#listen-时候参数-backlog-的意义"></a> listen 时候参数 backlog 的意义？</h3><p>Linux内核中会维护两个队列：</p><ul><li>未完成连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</li><li>已完成连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</li></ul><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/IpoBXFxgCAv5RfE.jpg"  alt="soket_listen_backlog" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span> <span class="params">(<span class="keyword">int</span> socketfd, <span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure><ul><li>参数一 socketfd 为 socketfd 文件描述符</li><li>参数二 backlog，这参数在历史有一定的变化</li></ul><p>在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。</p><p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p><h3 id="accept-发送在三次握手的哪一步"><a class="markdownIt-Anchor" href="#accept-发送在三次握手的哪一步"></a> accept 发送在三次握手的哪一步？</h3><p>先看看客户端连接服务端时，发送了什么？</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/pbCw3sSmLjRVZ9G.jpg"  alt="soket_link" /></p><ul><li>客户端的协议栈向服务器端发送了 <code>SYN包</code>，并告诉服务器端当前发送序列号 <code>client_isn</code>，客户端进入 <code>SYNC_SENT</code> 状态；</li><li>服务器端的协议栈收到这个包之后，和客户端进行 <code>ACK</code> 应答，应答的值为 <code>client_isn+1</code>，表示对 <code>SYN包 client_isn</code> 的确认，同时服务器也发送一个 <code>SYN包</code>，告诉客户端当前我的发送序列号为 <code>server_isn</code>，服务器端进入 <code>SYNC_RCVD</code> 状态；</li><li>客户端协议栈收到 <code>ACK</code> 之后，使得应用程序从 <code>connect</code> 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 <code>ESTABLISHED</code>，同时客户端协议栈也会对服务器端的 <code>SYN包</code>进行应答，应答数据为 <code>server_isn+1</code>；</li><li>应答包到达服务器端后，服务器端协议栈使得 <code>accept</code> 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 <code>ESTABLISHED</code> 状态。</li></ul><p>从上面的描述过程，我们可以得知<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p><h3 id="客户端调用-close-了连接是断开的流程是什么"><a class="markdownIt-Anchor" href="#客户端调用-close-了连接是断开的流程是什么"></a> 客户端调用 close 了，连接是断开的流程是什么？</h3><p>我们看看客户端主动调用了 <code>close</code>，会发生什么？</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/gwNbxRHQkv3ZjIl.jpg"  alt="soket_close" /></p><ul><li>客户端调用 <code>close</code>，表明客户端没有数据需要发送了，则此时会向服务端发送 <code>FIN</code> 报文，进入 <code>FIN_WAIT_1</code> 状态；</li><li>服务端接收到了 <code>FIN</code> 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 <code>EOF</code> 表示在该连接上再无额外数据到达。此时，服务端进入 <code>CLOSE_WAIT</code> 状态；</li><li>接着，当处理完数据后，自然就会读到 <code>EOF</code>，于是也调用 <code>close</code> 关闭它的套接字，这会使得会发出一个 FIN 包，之后处于 <code>LAST_ACK</code> 状态；</li><li>客户端接收到服务端的 FIN 包，并发送 <code>ACK</code> 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li><li>服务端收到 <code>ACK</code> 确认包后，就进入了最后的 <code>CLOSE</code> 状态；</li><li>客户端进过 <code>2MSL</code> 时间之后，也进入 <code>CLOSED</code> 状态；</li></ul><hr /><p>参考资料</p><p>[1] 趣谈网络协议专栏.刘超.极客时间.</p><p>[2] 网络编程实战专栏.盛延敏.极客时间.</p><p>[3] 计算机网络-自顶向下方法.陈鸣 译.机械工业出版社</p><p>[4] TCP/IP详解 卷1：协议.范建华 译.机械工业出版社</p><p>[5] 图解TCP/IP.竹下隆史.人民邮电出版社</p><p>[6] <a href="https://www.rfc-editor.org/rfc/rfc793.html" target="_blank" rel="noopener">https://www.rfc-editor.org/rfc/rfc793.html</a></p><p>[7] <a href="https://draveness.me/whys-the-design-tcp-three-way-handshake" target="_blank" rel="noopener">https://draveness.me/whys-the-design-tcp-three-way-handshake</a></p><p>[9] <a href="https://draveness.me/whys-the-design-tcp-time-wait" target="_blank" rel="noopener">https://draveness.me/whys-the-design-tcp-time-wait</a></p><hr />]]></content>
      
      
      <categories>
          
          <category> 干货分享 </category>
          
          <category> 面试相关 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> 面试 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谁要再用double定义商品金额，就自己收拾东西走人</title>
      <link href="/post/b1d4025b/"/>
      <url>/post/b1d4025b/</url>
      
        <content type="html"><![CDATA[<h1 id="现象"><a class="markdownIt-Anchor" href="#现象"></a> 现象</h1><p>当涉及诸如<code>float</code>或者<code>doble</code>这两种<code>浮点型数据</code>的处理时，会出现一些奇怪的现象：</p><p>举个栗子：</p><p><strong>现象一：条件判断超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.9999999f</span> );  <span class="comment">// 打印：false</span></span><br><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.99999999f</span> ); <span class="comment">// 打印：true   纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>现象二：数据转换超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br><span class="line"><span class="keyword">double</span> d = (<span class="keyword">double</span>) f;</span><br><span class="line">System.out.println(f);  <span class="comment">// 打印：1.1</span></span><br><span class="line">System.out.println(d);  <span class="comment">// 打印：1.100000023841858  纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>现象三：基本运算超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0.2</span> + <span class="number">0.7</span>) <span class="comment">// 打印：0.8999999999999999   纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>现象三：数据自增超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">8455263f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f1);</span><br><span class="line">    f1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印：8455263.0</span></span><br><span class="line"><span class="comment">// 打印：8455264.0</span></span><br><span class="line"><span class="comment">// 打印：8455265.0</span></span><br><span class="line"><span class="comment">// 打印：8455266.0</span></span><br><span class="line"><span class="comment">// 打印：8455267.0</span></span><br><span class="line"><span class="comment">// 打印：8455268.0</span></span><br><span class="line"><span class="comment">// 打印：8455269.0</span></span><br><span class="line"><span class="comment">// 打印：8455270.0</span></span><br><span class="line"><span class="comment">// 打印：8455271.0</span></span><br><span class="line"><span class="comment">// 打印：8455272.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">84552631f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f2);</span><br><span class="line">    f2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br></pre></td></tr></table></figure><hr /><p>这些简单场景下的使用情况都很难满足我们的需求，所以说用浮点数（包括<code>double</code>和<code>float</code>）处理问题有非常多<strong>隐晦的坑</strong></p><p>怪不得发狠话：谁要是敢在处理诸如 <strong>商品金额</strong>、<strong>订单交易</strong>、以及<strong>货币计算</strong>时用浮点型数据（<code>double</code>/<code>float</code>），直接让走人！</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/j49c6aprTsXyLnZ.png"  alt="640" /></p><hr /><h1 id="原因出在哪里"><a class="markdownIt-Anchor" href="#原因出在哪里"></a> 原因出在哪里？</h1><p>就以第一个典型现象为例来分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.99999999f</span> ); <span class="comment">// 打印：true</span></span><br></pre></td></tr></table></figure><p>直接用代码去比较<code>1</code>和<code>0.99999999</code>，居然打印出<code>true</code>！</p><p>这说明了什么？这说明了计算机压根<strong>区分不出来</strong>这两个数。这是为什么呢？</p><p>我们不妨来简单思考一下：</p><blockquote><p>我们知道输入的这两个浮点数只是我们人类肉眼所看到的具体数值，是我们通常所理解的十进制数</p><p>但是计算机底层在计算时可不是按照十进制来计算的</p><p>计算机底层最终都是基于像<code>010100100100110011011</code>这种<code>0</code>、<code>1</code>二进制来完成的。</p></blockquote><p>所以为了搞懂实际情况，我们应该将这两个十进制浮点数<strong>转化到二进制空间</strong>来看一看。</p><p><strong>十进制浮点数转二进制</strong> 怎么转、怎么计算？</p><p>我想这应该属于基础计算机进制转换常识，在 <strong>《计算机组成原理》</strong> 类似的课上肯定学过了，就不在此赘述了</p><p>直接给出结果（把它转换到<code>IEEE 754 Single precision 32-bit</code>，也就<code>float</code>类型对应的精度）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.0（十进制）</span><br><span class="line">    ↓</span><br><span class="line">00111111 10000000 00000000 00000000（二进制）</span><br><span class="line">    ↓</span><br><span class="line">0x3F800000（十六进制）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.99999999（十进制）</span><br><span class="line">    ↓</span><br><span class="line">00111111 10000000 00000000 00000000（二进制）</span><br><span class="line">    ↓</span><br><span class="line">0x3F800000（十六进制）</span><br></pre></td></tr></table></figure><p><strong>果不其然</strong>，这两个十进制浮点数的底层二进制表示是一模一样的，怪不得<code>==</code>的判断结果返回<code>true</code>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.9999999f</span> ); <span class="comment">// 打印：false</span></span><br></pre></td></tr></table></figure><p>但是<code>1f == 0.9999999f</code>返回的结果是符合预期的，打印<code>false</code>，我们也把它们转换到二进制模式下看看情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.0（十进制）</span><br><span class="line">    ↓</span><br><span class="line">00111111 10000000 00000000 00000000（二进制）</span><br><span class="line">    ↓</span><br><span class="line">0x3F800000（十六进制）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.9999999（十进制）</span><br><span class="line">    ↓</span><br><span class="line">00111111 01111111 11111111 11111110（二进制）</span><br><span class="line">    ↓</span><br><span class="line">0x3F7FFFFE（十六进制）</span><br></pre></td></tr></table></figure><p>很明显，它俩的二进制数字表示确实不一样，打印<code>false</code>理所应当的结果。</p><p>那么为什么<code>0.99999999</code>的底层二进制表示竟然是：<code>00111111 10000000 00000000 00000000</code>呢？</p><p>这不明明是浮点数<code>1.0</code>的二进制表示吗？</p><p>这就要谈一下浮点数的精度问题了。</p><hr /><h1 id="浮点数的精度问题"><a class="markdownIt-Anchor" href="#浮点数的精度问题"></a> 浮点数的精度问题</h1><p>学过 <strong>《计算机组成原理》</strong> 这门课的小伙伴应该都知道，浮点数在计算机中的存储方式遵循<strong>IEEE 754 浮点数计数标准</strong>，可以用科学计数法表示为：</p><blockquote><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>s</mi></msup><mo separator="true">⋅</mo><msup><mn>2</mn><mi>E</mi></msup><mo separator="true">⋅</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">V = (-1)^s·2^E·M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></p></blockquote><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 表示符号位，s = 0 为正，s = 1 为负</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">2^E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span> 表示指数位，阶码部分</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 表示尾数部分的位数，确定了浮点型的精度</li></ul><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>M</mi><mo>&lt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1&lt;=M&lt;2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p></blockquote><ul><li>也就是说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>可以写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msub><mi mathvariant="normal">.</mi><mrow><mi>x</mi><mn>1</mn><mi>x</mi><mn>2</mn><mi>x</mi><mn>3</mn><mi>x</mi><mn>4</mn></mrow></msub></mrow><annotation encoding="application/x-tex">1._{x1x2x3x4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">1</span><span class="mord"><span class="mord">.</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mtight">1</span><span class="mord mathdefault mtight">x</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">x</span><span class="mord mtight">3</span><span class="mord mathdefault mtight">x</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn><mi>x</mi><mn>2</mn><mi>x</mi><mn>3</mn><mi>x</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">x1x2x3x4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mord mathdefault">x</span><span class="mord">4</span></span></span></span>为小数部分</li></ul></blockquote><p>只要给出：<strong>符号（S）</strong>、<strong>阶码部分（E）</strong>、<strong>尾数部分（M）</strong> 这三个维度的信息，一个浮点数的表示就完全确定下来了，所以<code>float</code>和<code>double</code>这两种浮点数在内存中的存储结构如下所示：</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/PN9piLHAyQF5DWR.png"  alt="640-1586534583795" /></p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/ykiTljIWtrhE2HY.png"  alt="640-1586534589941" /></p><p><strong>1、符号部分（S）</strong></p><p><code>s = 0</code> 为正，<code>s = 1</code> 为负</p><p><strong>2、阶码部分（E）（指数部分）</strong>：</p><ul><li>对于<code>float</code>型浮点数，指数部分<code>8</code>位，考虑可正可负，因此可以表示的指数范围为<code>-127 ~ 128</code></li><li>对于<code>double</code>型浮点数，指数部分<code>11</code>位，考虑可正可负，因此可以表示的指数范围为<code>-1023 ~ 1024</code></li></ul><p><strong>3、尾数部分（M）</strong>：</p><p>浮点数的精度是由尾数的位数来决定的：</p><ul><li>对于<code>float</code>型浮点数，尾数部分<code>23</code>位，换算成十进制就是 <code>2^23=8388608</code>，所以十进制精度只有<code>6 ~ 7</code>位；</li><li>对于<code>double</code>型浮点数，尾数部分<code>52</code>位，换算成十进制就是 <code>2^52 = 4503599627370496</code>，所以十进制精度只有<code>15 ~ 16</code>位</li></ul><p>所以对于上面的数值<code>0.99999999f</code>，很明显已经超过了<code>float</code>型浮点数据的精度范围，出问题也是在所难免的。</p><hr /><h1 id="精度问题如何解决"><a class="markdownIt-Anchor" href="#精度问题如何解决"></a> 精度问题如何解决</h1><p>所以如果涉及<strong>商品金额</strong>、<strong>交易值</strong>、<strong>货币计算</strong>等这种对精度要求很高的场景该怎么办呢？</p><p><strong>方法一：用字符串或者数组解决多位数问题</strong></p><p>刷过算法题的小伙伴们应该都知道，用字符串或者数组表示大数是一个典型的解题思路。</p><p>比如经典面试题：<strong>编写两个任意位数大数的加法、减法、乘法等运算</strong>。</p><p>这时候我们可以用字符串或者数组来表示这种大数，然后按照四则运算的规则来手动模拟出具体计算过程，中间还需要考虑各种诸如：<strong>进位</strong>、<strong>借位</strong>、<strong>符号</strong>等等问题的处理，十分复杂，本文不做赘述。</p><p><strong>方法二：Java的大数类是个好东西</strong></p><p>JDK早已为我们考虑到了浮点数的计算精度问题，因此提供了专用于高精度数值计算的<strong>大数类</strong>来方便我们使用。</p><p>Java的大数类位于<code>java.math</code>包下：</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/11/6i1fBmzd3ELOKeX.png"  alt="640-1586534628290" /></p><p>常用的<code>BigInteger</code> 和 <code>BigDecimal</code>就是处理高精度数值计算的利器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal num3 = <span class="keyword">new</span> BigDecimal( Double.toString( <span class="number">1.0f</span> ) );</span><br><span class="line">BigDecimal num4 = <span class="keyword">new</span> BigDecimal( Double.toString( <span class="number">0.99999999f</span> ) );</span><br><span class="line">System.out.println( num3 == num4 );  <span class="comment">// 打印 false</span></span><br><span class="line"></span><br><span class="line">BigDecimal num1 = <span class="keyword">new</span> BigDecimal( Double.toString( <span class="number">0.2</span> ) );</span><br><span class="line">BigDecimal num2 = <span class="keyword">new</span> BigDecimal( Double.toString( <span class="number">0.7</span> ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line">System.out.println( num1.add( num2 ) );  <span class="comment">// 打印：0.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line">System.out.println( num2.subtract( num1 ) );  <span class="comment">// 打印：0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line">System.out.println( num1.multiply( num2 ) );  <span class="comment">// 打印：0.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line">System.out.println( num2.divide( num1 ) );  <span class="comment">// 打印：3.5</span></span><br></pre></td></tr></table></figure><p>当然了，像<code>BigInteger</code> 和 <code>BigDecimal</code>这种大数类的运算效率肯定是不如原生类型效率高，代价还是比较昂贵的，是否选用需要根据实际场景来评估。</p><hr />]]></content>
      
      
      <categories>
          
          <category> 开发要点 </category>
          
          <category> 数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 浮点型 </tag>
            
            <tag> 开发要点 </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
